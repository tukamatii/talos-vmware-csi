
# Руководство по участию в проекте

Мы рады вашему желанию внести свой вклад в наш проект\! Это руководство поможет вам понять наши стандарты и процессы, чтобы ваше участие было максимально эффективным и приятным.

Для поддержания порядка и согласованности в наших проектах GitLab, мы просим всех участников придерживаться правил, изложенных в этом документе.

Пожалуйста, ознакомьтесь с этим документом перед тем, как создавать Issues, Merge Requests или вносить изменения в код. Соблюдение этих рекомендаций значительно упростит процесс совместной работы, улучшит качество кода и ускорит интеграцию ваших изменений.

-----

## Содержание

- [Руководство по участию в проекте](#руководство-по-участию-в-проекте)
  - [Содержание](#содержание)
  - [1. Общие принципы](#1-общие-принципы)
  - [2. Сообщения коммитов (Commit Messages)](#2-сообщения-коммитов-commit-messages)
  - [3. Стиль названия веток (Branch Naming)](#3-стиль-названия-веток-branch-naming)
  - [4. Стиль названия версий и релизов (Version and Release Naming)](#4-стиль-названия-версий-и-релизов-version-and-release-naming)
  - [5. Стиль названия репозиториев (Repository Naming)](#5-стиль-названия-репозиториев-repository-naming)
  - [6. Процесс внесения изменений](#6-процесс-внесения-изменений)

-----

## 1\. Общие принципы

  * **Уважение**: Мы ценим вклад каждого участника. Будьте вежливы, конструктивны и профессиональны в общении, как при обсуждении идей, так и при предоставлении обратной связи по коду. Помните, что за каждым изменением стоит человек.
  * **Ясность**: Четкое и недвусмысленное формулирование мыслей, проблем и предложений является ключом к эффективной совместной работе. Это касается как описания Issues и Merge Requests, так и комментариев к коду. Чем яснее вы излагаете свою мысль, тем быстрее и точнее она будет понята.
  * **Согласованность**: Для поддержания чистоты и предсказуемости кодовой базы, а также для упрощения навигации по истории проекта, крайне важно следовать установленным стилям и соглашениям, описанным в этом документе. Отклонения от стандартов могут замедлить процесс ревью и интеграции.
  * **Тестирование**: Все вносимые изменения должны быть тщательно протестированы. Это включает в себя как автоматизированные (модульные, интеграционные, функциональные) тесты, так и ручное тестирование, если это применимо. Убедитесь, что ваши изменения не ломают существующую функциональность и корректно работают в различных сценариях.

-----

## 2\. Сообщения коммитов (Commit Messages)

Мы используем стандарт [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) для сообщений коммитов. Этот стандарт не только делает историю коммитов более читаемой и понятной для людей, но и позволяет автоматизировать такие процессы, как генерация логов изменений (changelog), определение семантических версий и даже автоматическое развертывание. Все сообщения коммитов должны быть написаны на **английском языке**.

**Формат:**

```
<type>(<scope>): <description>

[optional body]

[optional footer(s)]
```

**Примеры:**

  * `feat: add user authentication module`
  * `fix(auth): correct password reset bug`
  * `docs: update README with installation instructions`
  * `style: format code according to ESLint rules`
  * `refactor(api): restructure user endpoint logic`
  * `test: add unit tests for user service`
  * `chore: update dependencies`
  * `build: update webpack configuration`
  * `ci: configure GitHub Actions for continuous integration`
  * `perf: optimize image loading`

**Обязательные типы (`<type>`):** Каждый коммит должен начинаться с одного из следующих типов, указывающего на характер изменения:

  * `feat`: New feature, adding capabilities to the project. (Новая функциональность)
  * `fix`: Bug fix, correcting incorrect behavior. (Исправление ошибки)
  * `docs`: Changes only to documentation (e.g., README, JSDoc, comments). (Изменения в документации)
  * `style`: Changes that do not affect code logic but relate to formatting, indentation, syntax (e.g., missing semicolons, extra spaces). (Изменения форматирования, стиля кода)
  * `refactor`: Code changes that do not add functionality or fix bugs, but improve structure, readability, or performance (e.g., renaming variables, extracting functions). (Рефакторинг кода)
  * `test`: Adding missing tests or correcting existing tests. (Добавление или исправление тестов)
  * `chore`: Other changes not directly related to the application's source code (e.g., dependency updates, tool configuration changes). (Прочие изменения, не связанные напрямую с кодом приложения)
  * `build`: Changes that affect the build system or external dependencies (e.g., changes in package.json, webpack.config.js files). (Изменения, связанные со сборкой или внешними зависимостями)
  * `ci`: Changes to continuous integration/continuous deployment (CI/CD) files and scripts. (Изменения в CI/CD)
  * `perf`: Code changes aimed at improving performance. (Улучшения производительности)

`<scope>` (необязательно): Указывает на конкретную часть проекта, которой касаются изменения (например, `auth`, `ui`, `database`, `api`, `core`, `utils`). Использование `scope` помогает быстро понять, какая область кодовой базы была затронута.

`<description>`: Краткое, но информативное описание изменения, не превышающее 50-72 символов. Оно должно быть написано в повелительном наклонении (например, "add", "fix", "update"), как будто вы даете команду кодовой базе.

**Тело (необязательно)**: Если краткого описания недостаточно, используйте тело коммита для более подробного объяснения "что" и "почему" было изменено. Каждый абзац должен быть отдельной строкой. Здесь можно описать мотивацию для изменения, его реализацию и возможные побочные эффекты.

**Футер (необязательно)**: Используется для ссылки на связанные Issues в Jira (например, `JIRA_PROJECT_KEY-123`, `JIRA_PROJECT_KEY-456`) или для указания на ломающие изменения (`BREAKING CHANGE: <description of backward incompatible changes>`). Это критически важно для семантического версионирования.

-----

## 3\. Стиль названия веток (Branch Naming)

Названия веток должны быть ясными, краткими и сразу отражать их назначение. Мы используем гибридный подход, сочетающий элементы Git Flow и GitHub Flow, чтобы обеспечить гибкость и порядок.

**Основные типы веток:**

  * **`master`**: Это основная ветка, представляющая собой стабильный, готовый к развертыванию код. Все извщсыменения, попадающие сюда, должны быть тщательно протестированы и одобрены.
  * **`dev`**: Ветка для активной разработки. Она содержит последние интегрированные изменения из всех веток функциональности. Новые фичи обычно начинаются отсюда.
  * **`feature-<feature_name>`**: Используется для разработки новой функциональности.
      * Пример: `feature-user-profile-management`, `feature-payment-gateway-integration`
      * Правила: Название должно быть коротким, но достаточно описательным, чтобы понять суть фичи. Используйте **kebab-case** (слова разделены дефисами) для всех названий веток.
  * **`bugfix-<bug_description>`** (или `fix-<bug_description>`): Предназначена для исправления ошибок, найденных в ветке `dev` или в процессе тестирования.
      * Пример: `bugfix-login-issue-20240726`, `fix-api-timeout-handling`
      * Правила: Краткое, описательное название. Можно включить номер связанного Issue для быстрой привязки (например, `bugfix-JIRA_PROJECT_KEY-123-login-error`).
  * **`hotfix-<hotfix_description>`**: Для срочных исправлений критических ошибок, найденных в `master` (продакшн). Такие исправления должны быть минимальными и быстро развернуты.
      * Пример: `hotfix-critical-security-patch-v1.0.1`, `hotfix-broken-checkout-flow`
      * Правила: Короткое, описательное название, использующее **kebab-case**. После применения хотфикс должен быть объединен как в `master`, так и в `dev`.
  * **`release-<version>`**: Используется для подготовки нового релиза. В этой ветке проводятся последние тесты, исправления мелких багов, обновление документации и подготовка к выпуску.
      * Пример: `release-1.0.0`, `release-2.1.0-rc1`
      * Правила: Название должно точно соответствовать номеру версии, которую планируется выпустить.

**Общие правила для названий веток:**

  * Использовать только **строчные буквы**, чтобы избежать проблем с чувствительностью к регистру в разных операционных системах.
  * Слова разделять **дефисами** (`-`) (**kebab-case**), что улучшает читаемость и является стандартной практикой.
  * Избегать специальных символов, кроме дефисов и слэшей (`/`), так как они могут вызвать проблемы или быть неправильно интерпретированы.
  * Название должно быть кратким, но достаточно информативным, чтобы с первого взгляда понять назначение ветки.

-----

## 4\. Стиль названия версий и релизов (Version and Release Naming)

Мы строго придерживаемся [Semantic Versioning (SemVer)](https://semver.org/lang/ru/) для версионирования наших проектов. Это обеспечивает предсказуемость изменений в API и функциональности, что крайне важно для потребителей наших библиотек и сервисов, а также для управления зависимостями.

**Формат:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILDMETADATA]`

**Примеры:**

  * `1.0.0` (Первый стабильный релиз, без предварительных версий и метаданных)
  * `1.0.1` (Исправление ошибки в версии 1.0.0, обратно совместимо)
  * `1.1.0` (Добавление новой функциональности, обратно совместимо с 1.0.x)
  * `2.0.0` (Ломающие изменения, несовместимые с версией 1.x.x)
  * `1.0.0-alpha.1` (Предварительный релиз, альфа-версия, первый билд)
  * `1.0.0-beta.2+001` (Бета-версия, второй билд, с метаданными сборки)

**Правила:**

  * **MAJOR**: Увеличивается при внесении **обратно несовместимых изменений** (ломающие изменения API). Это означает, что пользователи предыдущей Major-версии не смогут просто обновить проект без изменения своего кода.
  * **MINOR**: Увеличивается при добавлении **новой функциональности**, которая является обратно совместимой. Это означает, что пользователи могут обновиться без изменения своего кода и получить новые возможности.
  * **PATCH**: Увеличивается при внесении **обратно совместимых исправлений ошибок**. Эти изменения не добавляют новой функциональности и не ломают существующую.
  * **PRERELEASE (необязательно)**: Префикс для предварительных релизов (например, `alpha`, `beta`, `rc` — release candidate). Используется для версий до стабильного релиза (например, `1.0.0-alpha.1`). Предварительные версии могут содержать нестабильный код или неполную функциональность.
  * **BUILDMETADATA (необязательно)**: Дополнительные метаданные сборки (например, хеш коммита, дата, номер сборки). Игнорируется при определении старшинства версий (например, `1.0.0+20240726.gitabc123`). Эти метаданные полезны для отслеживания конкретных сборок.

**Релизы:**

  * Название релиза в системах вроде GitLab Releases всегда должно соответствовать тегу версии (например, `v1.0.0`). Это обеспечивает четкую связь между тегом в репозитории и опубликованным релизом.
  * Описание релиза должно быть подробным и включать список всех значимых изменений, сгруппированных по типу (новые функции, исправления ошибок, улучшения производительности, ломающие изменения). Желательно указывать ссылки на соответствующие коммиты или Issues для удобства отслеживания. Хорошее описание релиза помогает пользователям быстро понять, что нового и какие изменения им стоит ожидать.

-----

## 5\. Стиль названия репозиториев (Repository Naming)

Названия репозиториев должны быть ясными, краткими и точно отражать их назначение. Это критически важно для организации проектов в рамках группы GitLab, облегчая поиск, навигацию и понимание структуры.

**Формат:** `project-name[-component][-type]`

**Примеры:**

  * `my-awesome-app` (Основное клиентское приложение)
  * `user-service` (Микросервис, отвечающий за управление пользователями)
  * `docs-portal` (Репозиторий, содержащий всю внутреннюю и внешнюю документацию)
  * `shared-ui-components` (Библиотека общих UI-компонентов, используемых в нескольких проектах)
  * `website-landing-page` (Репозиторий для главной страницы веб-сайта)
  * `api-gateway` (Шлюз API для маршрутизации запросов к микросервисам)
  * `data-processing-pipeline` (Репозиторий для скриптов обработки данных)

**Правила:**

  * Использовать только **строчные буквы**. Это обеспечивает единообразие и избегает потенциальных проблем с чувствительностью к регистру.
  * Слова разделять **дефисами** (`-`) (**kebab-case**). Это стандартная и наиболее читаемая конвенция для названий репозиториев.
  * Название должно быть уникальным в рамках группы GitLab и максимально описательным, чтобы с первого взгляда было понятно, что находится в репозитории.
  * Избегать произвольных аббревиатур, если только они не общеприняты и широко известны в индустрии (например, `api`, `ui`, `sdk`, `cli`).
  * По возможности, отражать тип репозитория (например, `service`, `library`, `docs`, `app`, `pipeline`). Это дополнительно уточняет назначение репозитория.

-----

## 6\. Процесс внесения изменений

Для обеспечения плавного и контролируемого процесса разработки, пожалуйста, следуйте этим шагам при внесении любых изменений:

1.  **Создайте Issue**: Прежде чем приступить к написанию кода, если вы хотите сообщить об ошибке, предложить новую функциональность или обсудить улучшение, сначала создайте соответствующее Issue в трекере задач проекта. Это позволит нам обсудить предложение, избежать дублирования работы и убедиться, что ваше изменение соответствует общим целям проекта.
2.  **Создайте ветку**: После того как Issue создано и обсуждено (если необходимо), создайте новую ветку от `dev` (или `master` для хотфиксов) с соответствующим названием, согласно правилам из [раздела 3](https://www.google.com/search?q=%233-%D1%81%D1%82%D0%B8%D0%BB%D1%8C-%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2%D0%B5%D1%82%D0%BE%D0%BA-branch-naming).
      * Сначала убедитесь, что ваша локальная ветка `dev` актуальна:
        ```bash
        git checkout dev
        git pull origin dev
        ```
      * Затем создайте новую ветку для ваших изменений:
        ```bash
        git checkout -b feature/your-feature-name # для новой функциональности
        git checkout -b bugfix/your-bug-description # для исправления ошибок
        ```
3.  **Внесите изменения**: Напишите код, следуя нашим стандартам форматирования, чистоты кода и архитектурным принципам. Старайтесь делать изменения сфокусированными и атомарными.
4.  **Напишите тесты**: Убедитесь, что ваши изменения покрыты соответствующими автоматизированными тестами (модульными, интеграционными). Если вы исправляете ошибку, добавьте тест, который воспроизводит эту ошибку и подтверждает ее исправление. Если добавляете новую функциональность, напишите тесты, которые проверяют ее корректную работу.
5.  **Создайте коммиты**: Делайте атомарные коммиты с ясными сообщениями, следуя правилам из [раздела 2](https://www.google.com/search?q=%232-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2-commit-messages). Каждый коммит должен представлять собой логически завершенное изменение.
6.  **Отправьте ветку**: После того как вы внесли все изменения и сделали коммиты, отправьте вашу ветку в удаленный репозиторий:
    ```bash
    git push origin your-branch-name
    ```
7.  **Создайте Merge Request (MR)**: Откройте Merge Request в GitLab, выбрав вашу ветку как исходную и `dev` (или `master` для хотфиксов) как целевую.
      * Убедитесь, что ваш MR имеет ясное название и подробное описание, объясняющее, что было сделано и почему.
      * Обязательно свяжите MR с соответствующим Issue в Jira, используя формат `JIRA_PROJECT_KEY-ISSUE_NUMBER` (например, `PROJ-123`).
8.  **Код-ревью**: Дождитесь ревью вашего кода. Будьте готовы ответить на вопросы, предоставить дополнительные пояснения и внести изменения на основе комментариев ревьюеров. Код-ревью — это важный этап для обеспечения качества и обмена знаниями.
9.  **Слияние**: После того как ваш Merge Request будет одобрен как минимум одним ревьюером и все проверки CI/CD пройдут успешно, ваш MR будет объединен с целевой веткой.

-----

Спасибо за ваш вклад\! Мы ценим ваше стремление сделать наш проект лучше и готовы помочь вам на каждом этапе.